## 해시 함수의 정의와 속성

- 해시(hash)는 컴퓨터 공학에서 매우 근본이 되는 알고리즘 중 하나
- 이미 여러 번 본 해시 알고리즘의 용도
- 해시 테이블에서 데이터를 저장할 위치를 찾기 위해
- 길이가 긴 데이터 둘을 빨리 비교하기 위해
- 단, 다른 경우만 빨리 비교 가능
- 누출되면 곤란한 데이터의 원본을 저장하지 않기 위해
- 용도에 따라 해시 알고리즘의 요구사항이 조금씩 달라질 수 있음


## 해시 함수의 정의

> 임의의 크기를 가진 값을 고정 크기의 값에 대응시키는 함수

![image](https://github.com/speculatingwook/data_structure-algorithm/assets/105579811/e6ec6900-12fe-4c10-859b-65df43fbbbae)


- 여전히 함수이므로 수학에서의 함수의 정의도 만족해야 함
![image](https://github.com/speculatingwook/data_structure-algorithm/assets/105579811/a1fb2181-f244-4267-9e59-ae43e12ae9d0)

그래서 일대일 함수도 만족을 한다.(입력값이 달라도 출력값이 달라질 수 있다.)

> 반대로, 입력값이 같으면 언제나 출력값도 같아야 한다.(결정론적 작동)

  
  
## 해시 알고리즘의 분류
- (비암호학적) 해시 함수
- 암호학적 해시 함수

- 체크섬(검사함, checksum)
- 순환 중복 검사(cyclic redundancy check, CRC)


## 모든 해시 알고리즘의 속성

### 효율성(effeciency)

### 균일성(uniformity)

- 해시 함수의 출력값이 고르게 분포될수록 균일성이 높음
- 입력값으로 기대하는 값에 대해(예: 모든 정수값, 사전에 있는 단어)
- 흔히 훌륭한 해시 함수는 균일성이 높아야 한다고 함
- 즉, 출력 범위 안의 모든 값들이 동일한 확률로 나와야 함(균등 분포)
- 이러면 해시 충돌이 적어 O(1) 해시 테이블을 기대할 수 있음
- 환벽한(perfect)한 해시 함수: 해시 충돌이 전혀 없는 함수
- 입력값이 매우 제한적일 경우에만 가능
- 이유: 나중에 생일 문제(birthday problem)에서 설명

### 균일성의 측정

- 카이제곱 검정(chi-squared test)을 이용
![image](https://github.com/speculatingwook/data_structure-algorithm/assets/105579811/f1f7691c-0f61-4079-aa30-d4dee3ac4fee)

- 결과가 0.95 ~ 1.05 사이면 균일한 분포를 가진 해시 함수라 봄
- 해시 값이 덜 중복되게 버킷 수를 정할 것(소수를 사용)

### 눈사태 효과(avalanche effect)
- 입력값이 약간만 바뀌어도 출력값이 굉장히 많이 바뀌는 것
- 보통 암호학적 알고리즘이 매우 선호하는 효과
- 알고리즘의 규칙을 쉽게 유추할 수 없음
- 엄격한 눈사태 기준(strict avalanche criterion, SAC)
- 입력값에서 1비트를 뒤집으면 출력값의 각 비트가 뒤집힐 확률이 50%
- 이 기준을 충족하는 해시 함수는 분포가 균일할 가능성이 매우 높음


## 지역 민감 해시(locality-sensitive hashing)

- 해시 충돌의 최소화 대신 최대화를 목표로 하는 알고리즘
- 비슷한 내용을 가진 데이터끼리 충돌해야 함
- 엄청나게 많은 데이터에서 비슷한 것들을 찾는 용도
    - 스팸 메일 찾기
    - 웹 검색 엔진에서 비슷한 문서 추천하기
    - 음원, 사진 등의 저작권 침해 검사
    - 등

## 효율성

- 보통 빠른 해시 함수를 선호함
- 공간을 더 낭비해도 빠른 접근 속도를 선호
    - 저장된 데이터를 빨리 찾는 용도로 사용하는 해시 함수
- 충돌이 좀 더 나더라도 더 빠른 함수를 선호
    - 어차피 해시 충돌은 드문 일
    - 몇 개 난다고 O(1)에서 크게 느려지지 않음
- 하지만 하드웨어 가속이 어려운 해시를 선호하는 경우도 있음
    - 여전히 소프트웨어에서는 빨리 실행되는 걸 선호
    - 뒤에 암호학적 해시 알고리즘에서 자세히 설명

## 암호학적 해시 알고리즘의 추가 속성

- 역상 저항성(pre-image resistance)
- 제 2 역상 저항성(seconde pre-image resistance)
- 충돌 저항성(collision resistance)

## (비암호학적) 해시 함수

- 암호학적으로 사용하기에 안전하지 않은 해시 함수들
- 보안적으로 문제없는 용도에 주로 사용
    - 데이터 저장 및 찾기(예: 해시 테이블)
    - 저장/전송 중에 생긴 데이터 오류 탐지
    - 고유한 ID 생성
    - 등
- 이미 이 해시 함수의 작동원리에 대해서는 잘 알고 있어야 함

## 절대 반지는 없다!

- 모든 데이터에 대해 최고의 결과를 보장하는 해시 함수는 존재하지 않음
- 입력값에 따라 다른 해시 함수를 사용하는 확률적 알고리즘은 존재
    - 유니버셜 해싱(universal hashing)
- 따라서 용도에 맞는 해시 함수를 사용하는 게 중요
    - Java에서 hashcode() 구현을 각 클래스에 맡긴 이유
- 심지어는 비트 패킹(bit-packing)도 해시 함수로 사용 가능
    - 단, 균일성이 높지 않을 수는 있음

### 비트패킹

## 해시 함수를 발명하는 경우는 흔치 않음

- 제한된 데이터를 사용하는 경우 정도만 직접 발명
- 그 외의 경우에는 보통 이미 존재하는 해시 알고리즘을 사용
    - 누군가가 피와 땀을 흘려 만들고 측정한 함수
    - 그 외 많은 사람들이 사용하며 검증한 함수
    - 보통 내가 사용하는 데이터는 아주 특별하지 않음
- 우리가 집중해야 할 부분
    - 어떤 연산들이 좋은 해시 함수들을 만드는가?
    - 어디에 어떤 해시 함수를 사용해야 하는가?

## 올바른 해시 함수를 고르는 법

1. 실제로 가지고 있는 데이터로 테스트하면서 측정을 한다
    1. 속도
    2. 해시 충돌 수
    3. 메모리(보통 크게 중요하지 않음)
    4. 균일성 측정(실무에서는 잘 안함)
2. 구글 성님께 물어본다(…)
    1. 내 데이터들이 일반적인 데이터인 경우

## 해시 함수 테스트

- 어떤 사람이 해시 함수를 테스트함
- 테스트에 사용한 키들
    1. 소문자 영어단어 216,553개
    2. 정수(1 ~ 216,553)
    3. 무작위로 뽑은 216,543개의 GUID

```jsx
| 해시 함수 | 영어단어 | 점수 | GUID |
|----------|----------|------|------|
| Murmur | 145ns<br>6번 충돌 | 259ns<br>5번 충돌 | 92ns<br>0번 충돌 |
| FNV-1a | 152ns<br>4번 충돌 | 504ns<br>4번 충돌 | 86ns<br>0번 충돌 |
| FNV-1 | 184ns<br>1번 충돌 | 730ns<br>5번 충돌 | 92ns<br>0번 충돌 |
| DJB2a | 158ns<br>5번 충돌 | 443ns<br>6번 충돌 | 91ns<br>0번 충돌 |
| DJB2 | 156ns<br>7번 충돌 | 437ns<br>6번 충돌 | 93ns<br>0번 충돌 |
| SDBM | 148ns<br>4번 충돌 | 484ns<br>6번 충돌 | 90ns<br>0번 충돌 |
| SuperFast<br>Hash | 164ns<br>85번 충돌 | 344ns<br>4번 충돌 | 118ns<br>18742번 충돌 |
| CRC32 | 250ns<br>2번 충돌 | 946ns<br>0번 충돌 | 130ns<br>0번 충돌 |
| LoseLose | 338ns<br>2151789번 충돌 | - | - |
```

## Lose Lose 해시 함수

- 프로그래밍 책에서 간단히 소개하려고 만든 코드
- 여기 보여준 코드는 C#
    - 대부분의 해시 함수는 부호 없는 정수형을 사용
    - Java만 부호 없는 정수형이 없음(…)
    - Java로 구현하려면 쓸데없는 짓을 해야 함
- 매우 간단하지만 충돌이 많음

```jsx
public uint LoseLose(byte[] str)
{
	uint hash = 0;
	foreach (byte c in str)
	{
		hash += c;
	}
	
	return hash;
}
```

![](https://i.imgur.com/UNCWdVL.png)


## Murmur 해시 함수

```jsx
uint32_t murmur3_32(const uint8_t* key, size_t len, uint32_t seed) {
   uint32_t h = seed;
   const uint8_t* data = (const uint8_t*)key;
   const int nblocks = len / 4;

   for (int i = 0; i < nblocks; i++) {
       uint32_t k = get_unaligned_le32(data + i * 4);
       k *= 0xcc9e2d51;
       k = (k << 15) | (k >> 17);
       k *= 0x1b873593;
       h ^= k;
       h = (h << 13) | (h >> 19);
       h = h * 5 + 0xe6546b64;
   }

   const uint8_t* tail = (const uint8_t*)(data + nblocks * 4);
   uint32_t k = 0;

   switch (len & 3) {
   case 3:
       k ^= tail[2] << 16;
   case 2:
       k ^= tail[1] << 8;
   case 1:
       k ^= tail[0];
       k *= 0xcc9e2d51;
       k = (k << 15) | (k >> 17);
       k *= 0x1b873593;
       h ^= k;
   }

   h ^= len;
   h ^= h >> 16;
   h *= 0x85ebca6b;
   h ^= h >> 13;
   h *= 0xc2b2ae35;
   h ^= h >> 16;

   return h;
}

// murmur_32_scramble(k) 내부 코드
k *= 0xcc9e2d51;
k = (k << 15) | (k >> 17);
k *= 0x1b873593;
```

## FNV-1 해시

```jsx
#define FNV_PRIME_32 16777619
#define FNV_OFFSET_32 2166136261U

uint32_t FNV32(const char *str, uint32_t len)
{
   uint32_t hash = FNV_OFFSET_32;
   for (uint32_t i = 0; i < len; ++i)
   {
       hash = hash * FNV_PRIME_32;
       hash = hash ^ str[i];
   }
   return hash;
}
```

### FNV-1

```jsx
#define FNV_PRIME_32 16777619
#define FNV_OFFSET_32 2166136261U

uint32_t FNV32(const char *str, uint32_t len)
{
    uint32_t hash = FNV_OFFSET_32;
    for (uint32_t i = 0; i < len; ++i)
    {
        hash = hash * FNV_PRIME_32;
        hash = hash ^ str[i];
    }
    return hash;
}
```

### FNV-1a

```jsx
#define FNV_PRIME_32 16777619
#define FNV_OFFSET_32 2166136261U

uint32_t FNV32(const char *str, uint32_t len)
{
    uint32_t hash = FNV_OFFSET_32;
    for (uint32_t i = 0; i < len; ++i)
    {
        hash = hash ^ str[i];
        hash = hash * FNV_PRIME_32;
    }
    return hash;
}
```

# 체크섬과 CRC

## 체크섬(checksum)

- 여러 데이터로부터 도출한 작은 크기의 데이터 하나
    - 보통 데이터에 있는 모든 바이트를 어떤 방식이로든 합함
- 해시 함수랑 매우 비슷한 개념
    - 출력값의 크기가 고정되어 있으면 해시 함수
![](https://i.imgur.com/vLPCBY0.png)


- 용도: 저장 혹은 전송 중에 발생한 오류를 찾아냄
    - 처음 데이터를 저장할 때 체크섬을 계산해 그것도 저장
    - 나중에 데이터를 읽을 때 다시 체크섬을 계산
    - 처음에 저장해둔 체크섬과 다르면 오류가 난 것

## 체크섬의 사용 예

### 주민등록 번호 유효성 검사

- 존재할 수 있는 번호인지 검사
    - 실제 존재 여부가 아님
    - 본인 인증도 아님
- 마지막 숫자는 다음 공식에 따라 계산
    - 11 - (([2, 3, 4, 5, 6, 7, 8, 9, 3, 3, 4, 5]) * [앞 12자리] % 11)
    - 결과가 10이면 0으로 표기, 11이면 1로 표기
- 사진 속의 예는 유효하지 않은 주민등록 번호
    - 마지막 자리가 1이 되어야 함

### 신용카드 번호의 유효성 검사

- 총 16자리
- 마지막 숫자를 룬(Luhn) 알고리즘으로 만듦

### ISBN의 유효성 검사

- ISBN 10(국제 표준 도서 번호)
    - 각 도서에 붙는 고유한 번호(총 10자리)
    - 역시 마지막 숫자가 체크섬
    - ([10, 9, 8, 7, 6, 5, 4, 3, 2, 1] *[앞 9자리, x]) % 11 == 0
    - x 값이 10이면 X로 표기
    - ISBN 13도 비슷한 규칙이 있음

## 체크섬 알고리즘은 매우 간단

- 보통 간단한 산술 연산
- 계산이 빠르고 추가 메모리가 거의 불필요
    - 네트워크 프로토콜에서 사용
    - 하드웨어로도 구현하기 쉬움
- 단, 모든 오류를 찾지는 못함
    - xor8은 `AB`와`BA`의 체크섬이 같음
    - 위치까지 고려한 다른 알고리즘도 존재(예: Adler-32, CRC)

## 체크섬은 데이터가 바뀐지만 확인

- 보통 복구는 신경쓰지 않음
- 따라서 체크섬이 일치하지 않으면?
    - 데이터 전송의 경우라면 재전송 요청
    - 저장중인 데이터라면? 바이요
- 데이터 복구를 지원하는 것도 있음
    - 오류 정정 코드(error-correcting code, ECC) 등
    - 보통 어느 정도까지만 복구 가능

## 체크섬과 미러 사이트

- 웹 사이트에서 유용한 프로그램을 배포할 경우 미러를 사용하기도 함
    - 유용한 프로그램이라 매우 많은 사람들이 다운로드
    - 한 웹사이트에서 트래픽 감당이 안됨
    - 다른 웹사이트에서 대신 파일을 호스팅
- 그런데 미러 사이트에서 내 프로그램에 스파이웨어를 넣으면?
    - 그걸 알아낼 수 있도록 내 웹사이트에 체크섬 값을 공개해 놓음
    - 사용자는 미러 사이트에서 받은 파일에 체크섬 알고리즘을 돌림
    - 그 둘이 일치하지 않으면 누군가 변조한 프로그램
- 주의: 미러 사이트에 공개해 놓은 체크섬 값과 비교하는 건 도움 안됨

## 패리티 비트(parity bit)

- 이진수로 저장된 데이터에 추가하는 1비트짜리 체크섬
- 보통 1바이트 단위로 많이 사용(7비트 데이터 + 1비트 패리티)
- 짝수 패리티와 홀수 패리티로 나뉨
    - 패리티까지 포함한 모든 비트를 더하면 그 결과가 짝수 또는 홀수가 되어야 함
    

```jsx
| 데이터 | 1비트 개수 | 패리티까지 포함한 데이터 |                |
|--------|------------|------------------------|----------------|
|        |            | 홀수 패리티            | 짝수 패리티    |
| 000 0000 | 0          | 1000 0000             | 0000 0000      |
| 010 1100 | 3          | 0010 1100             | 1010 1100      |
| 111 1111 | 7          | 0111 1111             | 1111 1111      |
```

## 순환 중복 검사(cyclic redundancy check)

- 체크섬 알고리즘 중 하나
- 다항식의 나머지 연산을 이용하여 검사값을 만듬
    - 검사값은 보통 고정된 길이
    - 따라서 CRC 함수를 해시 함수로 사용하기도 함
- 역시 이진수 하드웨어에서 구현하기 쉬움
    - 심지어 최신 CPU는 CRC-32C 명령어를 탑재!

### CRC의 다항식과 이름

- 다항식의 최고차항에 따라 CRC에 사용하는 비트 수가 달라짐
    - 각 항의 계수는 1 아니면 0
    - 최고차항의 계수는 언제나 1
- 다음 다항식을 이진수로 표현하면 $x^3 + x + 1$
    - 1011 (총 4비트) → 더 줄이면 → 011 (총 3비트)
    - 이건 CRC-3-GSM에 사용하는 다항식

```jsx
import java.util.zip.CRC32;
public class Program {
	public static void main(String[] args) {
		String input1 = "My text";
		String input2 = "My text";
		String input3 = "My different text";

		byte[] input1Bytes = input1.getBytes();
	    byte[] input2Bytes = input2.getBytes();
	    byte[] input3Bytes = input3.getBytes();

	    CRC32 crc32 = new CRC32();
    
	    try {        
	        crc32.update(input1Bytes);
	        long checksum1 = crc32.getValue();
	        System.out.println("input1: " + checksum1);

	        crc32.reset();
	        crc32.update(input2Bytes);  
	        long checksum2 = crc32.getValue();
	        System.out.println("input2: " + checksum2);

	        crc32.reset();
	        crc32.update(input3Bytes);
	        long checksum3 = crc32.getValue();
	        System.out.println("input3: " + checksum3);
	    } catch (Exception e) {
	        System.out.println("Error: " + e.getMessage());
	    }
}
```

## 암호학적 해시 알고리즘

- 해시값에서 원본 값을 찾는 게 사실상 실행 불가능한 알고리즘
    - 일방향 함수(one-way function)
    - 수학적인 지식이 많이 요구되는 부분
    - 따라서 이미 있는 해시 함수를 주로 사용
- 원본 값을 찾으려면 모든 조합을 모두 시도해봐야 함(무차별 대입 공격)
    - 이상적 목표
    - 암호학적 해시 함수로 분류된 것 중 이미 깨진 것들이 있음
- 보안 분야에서 다양한 용도로 사용

### 암호학적 해시 알고리즘

- 메시지나 파일의 무결성(integrity) 검사
    - 예: 앞에서 든 미러 사이트에서 파일 다운로드하기
- 디지털 서명 생성 및 검증
- 비밀번호 검증
- 작업 증명(proof-of-work, PoW)
    - 블록체인 등에서 서비스 거부 공격(DoS)을 어렵게 만들기 위해
- 일반 해시 알고리즘 대신으로 사용 가능

### 암호학적 해시 알고리즘의 예

```jsx
| 알고리듬 | 출력 비트 수 |
|----------|----------------|
| HAVAL | 256/224/192/160/128 |
| MD4 | 128 |
| MD5 | 128 |
| RIPEMD | 128 |
| RIPEMD-160 | 160 |
| SHA-1 | 160 |
| SHA-256/224 | 256/224 |
| SHA-512/384 | 512/384 |
| Tiger(2)-192/160/128 | 192/160/128 |
| WHIRLPOOL | 512 |
```

### 암호학적 해시 알고리즘의 추가 속성

- 역상 저항성(pre-image resistance)
- 제 2 역상 저항성(second pre-image resistance)
- 충돌 저항성(collision resistance)

### 역상 저항성(pre-image resistance)

- 해시값으로부터 원본 데이터를 찾기가 어려워함
    - 즉, 원본 데이터를 같이 저장하지 않는 용도에 적합
    - 예: 비밀번호 저장
- 비보안학적인 해시 함수에서 본 비트패킹은 역상 저항성이 거의 없음
    - 낮은 역상 저항성을 이용하는 게 역상 공격(pre-image attack)
    - 무차별 대입 공격을 통해서만 해시값을 찾을 수 있는 것이 이상적!
- 즉, 해시값으로부터 패턴을 보기 어려워야 함
    - 좋은 알고리즘의 필요성(예: 산사태 효과)
    - 해시값의 길이가 길수록 좋음

### 제 2 역상 저항성(seconde pre-image resistance)

- 똑같은 해시 값이 나오는 다른 입력값을 찾기 어려워함
    - (입력값, 해시값) 쌍을 이미 가지고 있을 때
    - 이 저항성이 낮으면 제2 역상 공격에 취약
- 역상 저항성보다 한 가지 정보가 더 있는 경우
    - 역상 저항성은 해시값만 있음
    - 제 2 역상 저항성은 입력값도 알고 있음

### 충돌 저항성(collision resistance)

- 해시 값이 똑같은 두 입력값을 찾기가 어려워야 함
    - 해시 값도 입력값도 주어지지 않는 경우
    - 이 저항성이 낮으면 충돌 공격에 취약
- 충돌 공격은 역상 공격들 보다 쉬움
    - 이미 MD5와 SHA-1에 대해 실행 가능한 충돌 공격이 발견됨
    - MD5는 일반 컴퓨터로 몇 초면 충분할 정도
    - 모든 암호학적 해시 함수는 생일 공격(birthday attack)이 가능하기 때문
    - 생일 공격은 무차별 대입 공격보다 빠름(이유: 생일 문제)

## 생일 문제

- 회사 직원 수는 20명
- 이 중에 생일이 9월 1일인 직원이 있을 확률은?