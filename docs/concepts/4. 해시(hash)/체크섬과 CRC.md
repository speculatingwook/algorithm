
## 체크섬(checksum)

- 여러 데이터로부터 도출한 작은 크기의 데이터 하나
    - 보통 데이터에 있는 모든 바이트를 어떤 방식이로든 합함
- 해시 함수랑 매우 비슷한 개념
    - 출력값의 크기가 고정되어 있으면 해시 함수
![](https://i.imgur.com/vLPCBY0.png)


- 용도: 저장 혹은 전송 중에 발생한 오류를 찾아냄
    - 처음 데이터를 저장할 때 체크섬을 계산해 그것도 저장
    - 나중에 데이터를 읽을 때 다시 체크섬을 계산
    - 처음에 저장해둔 체크섬과 다르면 오류가 난 것

## 체크섬의 사용 예

### 주민등록 번호 유효성 검사

- 존재할 수 있는 번호인지 검사
    - 실제 존재 여부가 아님
    - 본인 인증도 아님
- 마지막 숫자는 다음 공식에 따라 계산
    - 11 - (([2, 3, 4, 5, 6, 7, 8, 9, 3, 3, 4, 5]) * [앞 12자리] % 11)
    - 결과가 10이면 0으로 표기, 11이면 1로 표기
- 사진 속의 예는 유효하지 않은 주민등록 번호
    - 마지막 자리가 1이 되어야 함

### 신용카드 번호의 유효성 검사

- 총 16자리
- 마지막 숫자를 룬(Luhn) 알고리즘으로 만듦

### ISBN의 유효성 검사

- ISBN 10(국제 표준 도서 번호)
    - 각 도서에 붙는 고유한 번호(총 10자리)
    - 역시 마지막 숫자가 체크섬
    - ([10, 9, 8, 7, 6, 5, 4, 3, 2, 1] *[앞 9자리, x]) % 11 == 0
    - x 값이 10이면 X로 표기
    - ISBN 13도 비슷한 규칙이 있음

## 체크섬 알고리즘은 매우 간단

- 보통 간단한 산술 연산
- 계산이 빠르고 추가 메모리가 거의 불필요
    - 네트워크 프로토콜에서 사용
    - 하드웨어로도 구현하기 쉬움
- 단, 모든 오류를 찾지는 못함
    - xor8은 `AB`와`BA`의 체크섬이 같음
    - 위치까지 고려한 다른 알고리즘도 존재(예: Adler-32, CRC)

## 체크섬은 데이터가 바뀐지만 확인

- 보통 복구는 신경쓰지 않음
- 따라서 체크섬이 일치하지 않으면?
    - 데이터 전송의 경우라면 재전송 요청
    - 저장중인 데이터라면? 바이요
- 데이터 복구를 지원하는 것도 있음
    - 오류 정정 코드(error-correcting code, ECC) 등
    - 보통 어느 정도까지만 복구 가능

## 체크섬과 미러 사이트

- 웹 사이트에서 유용한 프로그램을 배포할 경우 미러를 사용하기도 함
    - 유용한 프로그램이라 매우 많은 사람들이 다운로드
    - 한 웹사이트에서 트래픽 감당이 안됨
    - 다른 웹사이트에서 대신 파일을 호스팅
- 그런데 미러 사이트에서 내 프로그램에 스파이웨어를 넣으면?
    - 그걸 알아낼 수 있도록 내 웹사이트에 체크섬 값을 공개해 놓음
    - 사용자는 미러 사이트에서 받은 파일에 체크섬 알고리즘을 돌림
    - 그 둘이 일치하지 않으면 누군가 변조한 프로그램
- 주의: 미러 사이트에 공개해 놓은 체크섬 값과 비교하는 건 도움 안됨

## 패리티 비트(parity bit)

- 이진수로 저장된 데이터에 추가하는 1비트짜리 체크섬
- 보통 1바이트 단위로 많이 사용(7비트 데이터 + 1비트 패리티)
- 짝수 패리티와 홀수 패리티로 나뉨
    - 패리티까지 포함한 모든 비트를 더하면 그 결과가 짝수 또는 홀수가 되어야 함
    


| 데이터      | 1비트 개수 | 패리티까지 포함한 데이터 |           |
| -------- | ------ | ------------- | --------- |
|          |        | 홀수 패리티        | 짝수 패리티    |
| 000 0000 | 0      | 1000 0000     | 0000 0000 |
| 010 1100 | 3      | 0010 1100     | 1010 1100 |
| 111 1111 | 7      | 0111 1111     | 1111 1111 |


## 순환 중복 검사(cyclic redundancy check)

- 체크섬 알고리즘 중 하나
- 다항식의 나머지 연산을 이용하여 검사값을 만듬
    - 검사값은 보통 고정된 길이
    - 따라서 CRC 함수를 해시 함수로 사용하기도 함
- 역시 이진수 하드웨어에서 구현하기 쉬움
    - 심지어 최신 CPU는 CRC-32C 명령어를 탑재!

### CRC의 다항식과 이름

- 다항식의 최고차항에 따라 CRC에 사용하는 비트 수가 달라짐
    - 각 항의 계수는 1 아니면 0
    - 최고차항의 계수는 언제나 1
- 다음 다항식을 이진수로 표현하면 $x^3 + x + 1$
    - 1011 (총 4비트) → 더 줄이면 → 011 (총 3비트)
    - 이건 CRC-3-GSM에 사용하는 다항식

```jsx
import java.util.zip.CRC32;
public class Program {
	public static void main(String[] args) {
		String input1 = "My text";
		String input2 = "My text";
		String input3 = "My different text";

		byte[] input1Bytes = input1.getBytes();
	    byte[] input2Bytes = input2.getBytes();
	    byte[] input3Bytes = input3.getBytes();

	    CRC32 crc32 = new CRC32();
    
	    try {        
	        crc32.update(input1Bytes);
	        long checksum1 = crc32.getValue();
	        System.out.println("input1: " + checksum1);

	        crc32.reset();
	        crc32.update(input2Bytes);  
	        long checksum2 = crc32.getValue();
	        System.out.println("input2: " + checksum2);

	        crc32.reset();
	        crc32.update(input3Bytes);
	        long checksum3 = crc32.getValue();
	        System.out.println("input3: " + checksum3);
	    } catch (Exception e) {
	        System.out.println("Error: " + e.getMessage());
	    }
}
```
