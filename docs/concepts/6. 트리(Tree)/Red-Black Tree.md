## 레드-블랙 트리(red-black tree)
- 각 노드가 레드 혹은 블랙
	- 노드에 저장하는 데이터가 아님
	- 그냥 1비트짜리 추가 정보(굳이 빨강/검정이 아니어도 됨)
- 스스로 균형을 잡는(self-balancing) 트리
	- 그걸 통해 트리 높이를 최소로 보장
	- 균형을 잡는 시점은 삽입과 삭제 시
	- 그 외 연산은 BST와 동일(단, 탐색 속도가 BST보다 빠를 것임)



## 레드-블랙 트리의 특성(properties)
![|450](https://i.imgur.com/FEpkTX1.png)

1. 노드는 레드 또는 블랙이다.
2. 루트 노드는 블랙이다.
3. 모든 리프 노드(NIL)은 블랙이다.
4. 레드 노드의 자식은 모두 블랙이다.
5. 어떤 노드와 리프 사이에 있는 블랙 노드 수는 동일하다.
	- 블랙 노드에만 있는 제약
	- 이를 통해 블랙과 레드 노드 수의 균형을 맞춤
	- 이걸 위해 삽입/삭제 시 트리를 재배치하거나 노드의 색을 바꾸기도 함

### 위 특성의 영향
- 리프 노드는 데이터를 담지 않음(NIL)
- 다음과 같은 용어가 탄생
	- 블랙 깊이(black depth): 루트와 어떤 노드 사이에 있는 블랙 노드 수
	- 블랙 높이(black height): 어떤 노드와 리프 사이에 있는 블랙 수
- 가장 큰 리프 깊이가 가장 작은 것의 2배를 넘지 않음
	- 레드-블랙 트리가 보장하는 핵심 특성
	- 이진 트리 연산 시간이 O(N)이 되는 최악의 경우를 방지 -> O(logN)을 보장
	- C++의 std::map의 구현으로 일반적으로 사용되는 자료구조

## 레드 - 블랙 트리가 보장하는 핵심 특성의 증명
- 블랙 높이가 x인 트리가 있다고 해보자
- 루트 -> 리프의 길이가 최소인 경우는?
	- 블랙: x개
	- 레드: 0개
- 이제 레드 노드를 최대한 집어넣으려 시도하면?
	- 블랙 노드 사이에 하나씩만 넣을 수 있음
- 따라서 루트 -> 리프의 최대 길이는 2x개의 노드로 구성
	- 참고: NIL 리프 노드는 세지 않았음'

## 레드-블랙 트리의 연산
- 탐색: 이진 탐색 트리와 같음
	- 단, O(logN)을 보장
- 삽입과 삭제
	- 일단 무작정 삽입 혹은 삭제(특성이 망가질 수 있음)
	- 그 후, 망가진 특성을 고치려 트리의 구조를 재배치(회전) 혹은 노드 색을 바꿈
	- 완벽하진 않지만 탐색 시간 O(logN) 을 보장할 정도의 균형
	- 이 모두 O(logN)
		- 삽입 혹은 삭제 O(logN) <- 트리 깊이가 보장되기 때문
		- 트리 회전: O(1)
		- 색 바꾸기: O(1)