
## DFS

DFS는 그래프나 트리 구조에서 사용되는 탐색 알고리즘이다. 이름 그대로 '깊이 우선'으로 탐색을 진행하는 것이 특징이다.

작동 방식은 다음과 같다

1. 시작 노드를 선택하고 방문 표시를 한다.
2. 현재 노드와 인접한 노드 중 방문하지 않은 노드를 선택한다.
3. 선택한 노드로 이동하여 방문 표시를 하고, 이를 현재 노드로 삼는다.
4. 더 이상 방문할 수 있는 인접 노드가 없을 때까지 2-3 과정을 반복한다.
5. 막다른 길에 도달하면 이전 노드로 돌아가 다른 경로를 탐색한다.

DFS는 재귀 함수나 스택을 이용해 구현할 수 있다. 재귀적 방법이 개념적으로 이해하기 쉽지만, 깊이가 매우 깊은 경우 스택 오버플로우가 발생할 수 있어 주의가 필요하다.

### DFS 장점
- 메모리 사용이 적다. 현재 경로상의 노드들만 기억하면 되기 때문이다.
- 목표 노드가 깊은 단계에 있을 때 BFS보다 빠르게 찾을 수 있다.
- 모든 노드를 방문하고자 할 때 적합하다.
## DFS 단점
- 해를 찾더라도 그것이 최단 경로임을 보장할 수 없다.
- 무한 깊이의 경로가 존재할 경우 탐색이 끝나지 않을 수 있다.

### DFS 코드
![|286](https://i.imgur.com/hGzTtci.png)

```java
public static void searchDepthFirst(Node node) {
	Stack<Node> stack = new Stack<>();
	
	stack.push(node);
	
	while(!stack.empty()) {
		Node next = stack.pop();
		
		System.out.println(next.data);
		
		for(Node child: next.children) {
			stack.push(child);
		}
	}
}
```

## BFS

BFS는 그래프 탐색 알고리즘 중 하나로, '너비 우선'으로 탐색을 진행한다. 시작 노드에서 가까운 노드부터 차례대로 탐색하는 것이 특징이다.

BFS의 작동 방식은 다음과 같다

1. 시작 노드를 선택하고 큐에 넣는다.
2. 큐에서 노드를 꺼내 방문 표시를 한다.
3. 꺼낸 노드의 인접 노드 중 방문하지 않은 노드를 모두 큐에 넣는다.
4. 큐가 빌 때까지 2-3 과정을 반복한다.

BFS는 주로 큐를 이용해 구현한다. 이는 '선입선출' 특성을 가진 큐가 같은 레벨의 노드들을 순차적으로 처리하는 데 적합하기 때문이다.

### BFS 장점
- 출발 노드에서 목표 노드까지의 최단 경로를 보장한다.
- 노드 간 거리가 모두 동일할 때 최적의 해를 찾는다.
- 무한 그래프에서도 해를 찾을 수 있다.

### BFS 단점
- DFS에 비해 더 많은 메모리를 사용한다. 인접한 모든 노드를 저장해야 하기 때문이다.
- 그래프의 깊이가 깊을 경우 DFS보다 속도가 느릴 수 있다.


## BFS vs DFS

| 깊이 우선 탐색(DFS) | 너비 우선 탐색(BFS) |
|-------------------|-------------------|
| • 자식부터 탐색 | • 이웃부터 탐색 |
| • 관련 자료구조: 스택 | • 관련 자료구조: 큐 |
| • 장점 | • 장점 |
|   ▷ 재귀 함수 호출로 간단히 구현 가능 |   ▷ 언제나 최소 깊이의 결과를 찾음 |
|   ▷ 보통 BFS 보다 메모리 사용량이 적음 |   ▷ 깊이가 무한인 트리에도 사용 가능 |
|   ▷ 캐시 메모리에 좀 더 친화적 | |
|   ▷ 병렬처리에 더 적합 | |
